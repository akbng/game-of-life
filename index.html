<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Game of Life</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      .btn {
        padding: 0.74em 1.2em;
        border: 1px solid #003049;
        border-radius: 4px;
        background-color: #e5e5e5;
        color: #003049;
        width: 80px;
        box-shadow: none;
        position: absolute;
        bottom: 20px;
        left: 20px;
        z-index: 100;
        text-transform: uppercase;
      }
      .start {
        z-index: 1000;
        animation: grow-out 1s ease-in 5s reverse both;
      }
      .clear {
        animation: slide 1s ease-in 5s reverse both;
      }
      canvas {
        border: 1px solid #003049;
        margin: 20px;
      }
      @keyframes grow-out {
        0% {
          width: 80px;
          visibility: visible;
        }
        75% {
          visibility: hidden;
        }
        100% {
          width: 240px;
          visibility: hidden;
        }
      }
      @keyframes slide {
        0% {
          left: 20px;
        }
        100% {
          left: 180px;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="400" height="400"></canvas>
    <!-- <div class="parent"></div> -->
    <button class="btn start">Start</button>
    <button class="btn stop" disabled>Stop</button>
    <button class="btn clear">Clear</button>
  </body>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    const boxWidth = 10;
    const numberOfHorizontalBox = Math.floor(canvasWidth / boxWidth);
    const numberOfVerticalBox = Math.floor(canvasHeight / boxWidth);

    let table = Array.from(new Array(numberOfHorizontalBox).keys()).map((_) =>
      Array.from(new Array(numberOfVerticalBox).keys()).map((_) => 0)
    );

    const startButton = document.querySelector(".start");
    const stopButton = document.querySelector(".stop");
    const clearButton = document.querySelector(".clear");

    let running = null;
    let painting = false;

    function startSimulation() {
      draw(nextGeneration(table));
      table = nextGeneration(table);
    }

    startButton.addEventListener("click", (event) => {
      if (running) return;

      running = setInterval(startSimulation, 100);
      startButton.disabled = true;
      stopButton.disabled = false;
    });

    stopButton.addEventListener("click", (event) => {
      if (!running) return;
      clearInterval(running);
      running = null;
      startButton.disabled = false;
      stopButton.disabled = true;
    });

    clearButton.addEventListener("click", (event) => {
      table = Array.from(new Array(numberOfHorizontalBox).keys()).map((_) =>
        Array.from(new Array(numberOfVerticalBox).keys()).map((_) => 0)
      );
      draw(table);
    });

    canvas.addEventListener("mousedown", (event) => {
      painting = true;
      const x = Math.floor(event.offsetX / boxWidth);
      const y = Math.floor(event.offsetY / boxWidth);
      table[y][x] = 1;
      draw(table);
    });

    canvas.addEventListener("mousemove", (event) => {
      if (!painting) return;
      const x = Math.floor(event.offsetX / boxWidth);
      const y = Math.floor(event.offsetY / boxWidth);
      table[y][x] = 1;
      draw(table);
    });

    canvas.addEventListener("mouseup", (event) => {
      painting = false;
    });

    function draw(arr) {
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      ctx.fillStyle = "#d62828";
      arr.forEach((array, i) => {
        array.forEach((element, j) => {
          if (element)
            ctx.fillRect(j * boxWidth, i * boxWidth, boxWidth, boxWidth);
        });
      });
    }

    function countLiveNeighbors(x, y, table) {
      let count = 0;
      for (
        let i = Math.max(0, x - 1);
        i <= Math.min(numberOfVerticalBox - 1, x + 1);
        i++
      ) {
        for (
          let j = Math.max(0, y - 1);
          j <= Math.min(numberOfHorizontalBox - 1, y + 1);
          j++
        ) {
          if (table[i][j] === 0 || (i === x && j === y)) continue;
          count++;
        }
      }
      return count;
    }

    function nextGeneration(table) {
      const grid = Array.from(new Array(numberOfHorizontalBox).keys()).map(
        (_) => Array.from(new Array(numberOfVerticalBox).keys()).map((_) => 0)
      );
      for (let i = 0; i < numberOfVerticalBox; i++) {
        for (let j = 0; j < numberOfHorizontalBox; j++) {
          const neighbors = countLiveNeighbors(i, j, table);
          if (neighbors < 2 || neighbors > 3) grid[i][j] = 0;
          else if (neighbors === 2) grid[i][j] = table[i][j];
          else grid[i][j] = 1;
        }
      }
      return grid;
    }

    draw(table);
  </script>
  <!-- <script src="game.js"></script> -->
</html>
